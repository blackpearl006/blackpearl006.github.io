<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>An end to end tutorial for extraction of FMR timeseries from ADNI Dataset with codes.</p> <p>By the end of this tutorial/ article, you will be able to extract FMRI timeseries at a desired voxel location. We will extract FMR timeseries at 160 Dosenbach ROIs from 6 classical brain networks ie. Default-mode(34), Frontoparietal(34), Sensorimotor(30), Cingulo-opercular(33), Cerebellum(18), Occipital(21).</p> <p>Link to <a href="https://github.com/blackpearl006/MRI-analysis-using-FSL/tree/main/CN_scripts" rel="external nofollow noopener" target="_blank">scripts</a></p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*rMyZqdvIonn40673"></figure> <h4>Download the fMRI and sMRI</h4> <p>Download the fMRI data with it’s corresponding sMRI image. For this tutorial, I have used ADNI dataset and have downloded Resting state fMRI and MPRAGE images. For a subject we can have mutiple visits contributing to multiple images. The downloaded images will be a specific file structure and will be in Dicom format.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/596/1*PlxWWxSRXf_JV7gWABsHAw.png"><figcaption>The file structure from the downloaded ADNI dataset, Here CN corresponds to Cognitively Normal Subjects</figcaption></figure> <h4>Conversion to Dicom to NifTi</h4> <p>Convert the Dicom files to NifTi files using dicom2nifti python library and save the images in another folder which is given by outpath.</p> <pre>#script name: dcmtonii_CN.py<br>import dicom2nifti<br>import os<br><br>path = 'path/CN/ADNI'<br>outpath='path/CNnifti'<br><br>for subject in os.listdir(os.path.join(path)):<br>    for modality in os.listdir(os.path.join(path,subject)):<br>        for visit in os.listdir(os.path.join(path,subject,modality)):<br>            for someid in os.listdir(os.path.join(path,subject,modality,visit)):<br>                inpath = os.path.join(path,subject,modality,visit,someid)<br>                out_path = os.path.join(outpath,subject,modality,visit)<br>                print(subject)<br>                if not os.path.exists(out_path):<br>                    os.makedirs(out_path)<br>                dicom2nifti.convert_directory(inpath, out_path, compression=True, reorient=True)</pre> <p>Alternatively you can use dcm2niix command line package to achieve the same results</p> <pre>module load pigz-2.4<br>out_dir="path/to/CN_nifti"<br>mkdir -p $out_dir<br>dcm2niix -f %i_%t -o $out_dir -z y path/CN/ADNI<br>#change the outputfolder accordingly, this script will store all the nifti <br># inside the outdir with id followed by the visit time eg: 002_S_0295_20110602075850<br><br># check what will be the output folder structure when you do not specify the path</pre> <figure><img alt="" src="https://cdn-images-1.medium.com/max/558/1*4Mag_OCPGEgXZgEyUru3PQ.png"><figcaption>The output file structure</figcaption></figure> <h4>Changing the file structure</h4> <p>We will change the file structure and of CNnifti to another folder ‘CNStandard_name’ with subject folder each with 2 NifTI images subjectid_visitdate_f &amp; subjectid_visitdata_s referring functional and structural MRI images respectively. There are multiple files for both the resting state fMRI and sMRI (MPRAGE) and both of the scans are not acquired in the same day. The sMRI is only utilised for linear registration and to obtain a mask of the White Matter and CSF in the brain so we only use the sMRI from the earliest visit by a subject along with fMRI from all visits. The first script handles functional data and the second script handles structural data.</p> <pre>#!/bin/bash<br>#script name : rename.sh<br>base_dir="/path/CNnifti"<br>out_dir="path/CNStandard_name"<br>for subject_dir in "$base_dir"/*; do<br>    if [[ -d "$subject_dir" ]]; then<br>        for subject_modality in "$subject_dir"/*; do<br>            if [[ -d "$subject_modality" ]]; then<br>                for subject_visit in "$subject_modality"/*; do<br>                    if [[ -d "$subject_visit" ]]; then<br>                        visit_date=$(basename "$subject_visit")<br>                        subject_name=$(basename "$subject_dir")<br>                        nifti_files=("$subject_visit"/*.nii.gz)<br>                        for nifti_file in "${nifti_files[@]}"; do<br>                            nifti_filename=$(basename "$nifti_file" .nii.gz)<br>                            if [[ $nifti_filename == *"resting"* ]]; then<br>                                newdirname=${subject_name}_${visit_date:0:10}<br>                                mkdir -p "$out_dir/$newdirname"<br>                                trimmed_filename="${newdirname}_f"<br>                                cp "$nifti_file" "$out_dir/$newdirname/$trimmed_filename.nii.gz"<br>                            fi<br>                        done<br>                    fi<br>                done<br>            fi<br>        done<br>    fi<br>done    </pre> <pre>#!/bin/bash<br>#script name : renames.sh<br>base_dir="/path/CNnifti"<br>out_dir="path/CNStandard_name"<br>for subject_dir in "$base_dir"/*; do<br>    if [[ -d "$subject_dir" ]]; then<br>        for subject_modality in "$subject_dir"/*; do<br>            if [[ -d "$subject_modality" ]]; then<br>                for subject_visit in "$subject_modality"/*; do<br>                    if [[ -d "$subject_visit" ]]; then<br>                        visit_date=$(basename "$subject_visit")<br>                        subject_name=$(basename "$subject_dir")<br>                        echo $subject_name<br>                        nifti_files=("$subject_visit"/*.nii.gz)<br>                        for nifti_file in "${nifti_files[@]}"; do<br>                            nifti_filename=$(basename "$nifti_file" .nii.gz)<br>                            if [[ $nifti_filename == *"mprage"* ]]; then<br>                                for allfmr in "$out_dir/$subject_name*"; do<br>                                    for i in $allfmr;do<br>                                        final_subject_name=$(basename "$i")<br>                                        trimmed_filename="${final_subject_name}_s"<br>                                        # echo "$i/$trimmed_filename.nii.gz"<br>                                        cp "$nifti_file" "$i/$trimmed_filename.nii.gz"<br>                                    done<br>                                done<br>                                break<br>                            fi<br>                        done<br>                    fi<br>                done<br>            fi<br>        done<br>    fi<br>done    </pre> <h4>Preprocessing Structural MRI images</h4> <p>We will process the sMRI images stored as subjectid_visitdate_s using 2 tools from FSL, {<a href="https://medium.com/@daminininad/mri-preprocessing-using-fsl-383a67e7185" rel="external nofollow noopener" target="_blank">link</a>} <br>1. robustfov → Reduce FOV of image to remove lower head and neck<br>2. bet2 → Brain Extraction tool</p> <p>output of the robustfov is subjectid_visitdate_r, which acts as a input to bet2 and produces subjectid_visitdate_sbrain . Lower fractional intensity value (f) is preferred. Set it according to your dataset. {Script}</p> <pre>#!/bin/bash<br>#script name : bet_CN.sh<br>base_dir="path/CNStandard_name"<br>for subject_dir in "$base_dir"/*; do<br>    if [[ -d "$subject_dir" ]]; then<br>        subject_name=$(basename "$subject_dir")<br>        # echo "$subject_name"<br>        in_img="$subject_dir/${subject_name}_s.nii.gz"<br>        robust_img="$subject_dir/${subject_name}_rbrain" <br>        out_img="$subject_dir/${subject_name}_sbrain" <br>        robustfov -i $in_img -r $robust_img <br>        bet2 $robust_img $out_img -f 0.3 <br>    fi<br>done</pre> <h4>Preprocessing Functional MRI images</h4> <p>We will process fMRI images stored as subjectid_visitdate_f using First level (1 subject) Preprocessing through FEAT tool from FSL. Through FEAT we will delete initial 10 volumes, use MCFLIRT motion correction, Change Slice timing correction for ADNI3 dataset, Perform brain extraction perform spatial smoothing of 5mm and perform Highpass temporal filtering. We will also register (linear 12 DOF) the fMRI data to it’s corresponding structural image ie. subjectid_visitdate_sbrain and also to the MNI152 space. Using FEAT GUI perform this on one subject and click Save/ Go. You will find a <strong>design.fsf</strong> file in the output.feat directory. This file has all the parameters required to run feat analysis of a particular subject and allows you to run the FEAT analysis on terminal. With few changes in the design file we can run the feat analysis on other subjects on terminal. We will copy this design.fsf file to each subject folder in CNStandard_name and change few parameters in the desgin.fsf through sed command.</p> <blockquote>change 002_S_2010_2011-01-22 to the subjectid_visitdate that you used to run FEAT to get design file. Check few design files manually.</blockquote> <pre>#!/bin/bash<br>#script name : prepare.sh<br>designfile='path/CNStandard_name/design.fsf' <br># path to the desgin file<br>base_dir="path/CNStandard_name"<br>for subject_dir in "$base_dir"/*; do<br>    if [[ -d "$subject_dir" ]]; then<br>        subject_name=$(basename "$subject_dir")<br>        echo "Processing subject: $subject_name"<br>        # new_designfile="${subject_dir}/${subject_name}.fsf"<br>        new_designfile="${subject_dir}/design.fsf"<br>        # echo $new_designfile<br>        cp "$designfile" "$new_designfile"<br>        sed -i "s/002_S_2010_2011-01-22/$subject_name/g" "$new_designfile"<br>        sed -i "s/002_S_2010_2011-01-22_f/${subject_name}_f/g" "$new_designfile"<br>        sed -i "s/002_S_2010_2011-01-22_sbrain/${subject_name}_sbrain/g" "$new_designfile"<br>        echo "Design file copied and modified for $subject_name"<br>    fi<br>done</pre> <p>FEAT analysis provides preprocessed fMRI as<strong> filtered_func_data.nii.gz</strong> file<br>The script to run the FEAT analysis for each subject is below</p> <pre>#!/bin/bash<br>#script name : feat_CN.sh<br>base_dir="path/CNStandard_name"<br>for subject_dir in "$base_dir"/*; do<br>    if [[ -d "$subject_dir" ]]; then<br>        subject_name=$(basename "$subject_dir")<br>        echo "$subject_name"<br>        cd "$subject_dir"<br>        if [ -e *sbrain.nii.gz ] &amp;&amp; [ -e *f.nii.gz ]; then<br>            echo "found $subject_name"<br>            feat design.fsf<br>        else<br>            echo "NOT FOUND $subject_name"<br>        fi<br>    fi<br>done</pre> <figure><img alt="" src="https://cdn-images-1.medium.com/max/598/1*ROg8FK1Ko3tmGN_282S_hA.png"><figcaption>The file structure after running FEAT. To get the .feat folder your subject folder should contain _f.nii.gz _sbrain.nii.gz and desgin.fsf. If you are getting only 002_S_2010_2011–01–22.feat, change the subjectname in the prepare.sh file</figcaption></figure> <h4>Processing fMRI</h4> <p>We know the brain consists of White Matter (WM), Grey Matter (GM) and Cerebrospinal fluid (CSF). Gray matter is composed of the soma, which houses cell organelles like mitochondria. Most of the studies consider only gray matter to contribute towards the neural activity, as it has the synaptic junctions which account for the larger part of brain’s energy consumption detected by fMRI.</p> <pre>#!/bin/bash<br><br>#script name : afterfeat_CN.sh<br>base_dir="path/CNStandard_name"<br>for subject_dir in "$base_dir"/*.feat; do<br>    if [[ -d "$subject_dir" ]]; then<br>        subject_name=$(basename "$subject_dir")<br>        echo $subject_name<br>        cd "$base_dir/$subject_name"<br>        # step 1<br>        fast -t 1 -n 3 -H 0.1 -I 4 -l 20.0 -o reg/highres2standard reg/highres2standard.nii.gz<br>        # step 2<br>        convert_xfm -omat reg/invfunc2standard.mat -inverse reg/example_func2standard.mat<br>        flirt -in reg/highres2standard_pve_0.nii.gz -ref filtered_func_data.nii.gz -applyxfm -init reg/invfunc2standard.mat -out reg/highres2standard_csf_reg.nii.gz<br>        flirt -in reg/highres2standard_pve_2.nii.gz -ref filtered_func_data.nii.gz -applyxfm -init reg/invfunc2standard.mat -out reg/highres2standard_wm_reg.nii.gz<br>        # step 3<br>        fslmaths reg/highres2standard_csf_reg.nii.gz -thr 0.95 reg/csf_mask_95.nii.gz<br>        fslmaths reg/highres2standard_wm_reg.nii.gz -thr 0.95 reg/wm_mask_95.nii.gz<br>        # step 4<br>        fslmeants -i filtered_func_data.nii.gz -o csf_with_noise.txt -m reg/csf_mask_95.nii.gz <br>        fslmeants -i filtered_func_data.nii.gz -o wm_with_noise.txt -m reg/wm_mask_95.nii.gz <br>        # step 5<br>        paste csf_with_noise.txt wm_with_noise.txt mc/prefiltered_func_data_mcf.par |tr -d "\t" &gt; paraorig.txt <br>        Text2Vest paraorig.txt paraorig.mat<br>        # step 6<br>        fsl_glm -i filtered_func_data.nii.gz -d paraorig.mat --out_res=res_brain.nii.gz<br>        # step 7<br>        flirt -in res_brain.nii.gz -ref reg/standard.nii.gz -applyxfm -init reg/example_func2standard.mat -out res_brain_std.nii.gz<br>        # step 8<br>        fslmaths reg/standard.nii.gz -mul 0 -Tmin -bin roi_template.nii.gz<br>    fi<br>done</pre> <p>There are 2 spaces that we will be working on Functional space (reference: fMRI → filtered_func_data.nii.gz) and Structural space (reference: sMRI → reg/highres2standard.nii.gz)</p> <ol> <li>Brain Matter Segmentation<br>Using FSL FAST tool we get WM, GM and CSF segmented images from the structural image. (The input is highres2standard.nii.gz which is same as subjectid_visitdate_sbrain.nii.gz registered to MNI152 space)</li> <li>Structural to Functional space<br>Convert WM and CSF Segmented images from structural space to functional space using FLIRT</li> <li>Create Mask<br>By thresholding the amount of CSF / WM is present in the voxel we create binary mask for both the WM and CSF brain matter</li> <li>FSL Mean time series (fslmeants)<br>For both WM and CSF multiply the mask with fMRI and get a mean timeseries for these brain matter</li> <li>Paraorigin.mat<br>Concatenate both these timeseries and to account for the motion correction add mc/prefiltered_func_data_mcf.par and convert that to a .mat file</li> <li>Temporal regression<br>Using this paraorigin.mat perform temporal regression on the fMRI to remove out the contributions from WM and CSF</li> <li>MNI space<br>Register the res_brain to MNI space</li> <li>ROI Template<br>Create a blank canvas with reference to the MNI standard space image where we will plot ROI</li> </ol> <h4>Timeseries extraction</h4> <p>You can get MNI co-ordinate for each of the 160 Dosenbach ROIs from the script below.</p> <pre>from nilearn import datasets<br>rois = datasets.fetch_coords_dosenbach_2010()['rois']<br>labels = datasets.fetch_coords_dosenbach_2010()['networks'] #which network do they belong to</pre> <p>We have the MNI coordinates of the ROIs belonging to each brain network in a txt files inside the DoschenbachROI folder.<br>Based on the MNI coordinates point in the roitemplate image that we have created. Then create a sphere of 5mm radius at this point. Get the mean timeseries across the fMRI using fslmeants. Append the timeseries into a csv file. This csv file will have 1 column and all timeseries from each ROI following once after another.</p> <pre>#!/bin/bash<br><br>#script name : ts_extract_CN.sh<br>base_dir="path/CNStandard_name"<br>for i in CB DMN FP OP CO SM; do<br>    file_path="path/DoschenbachROI/$i.txt"<br>    for subject_dir in "$base_dir"/*.feat; do<br>        if [[ -d "$subject_dir" ]]; then<br>            subject_name=$(basename "$subject_dir")<br>            echo $subject_name<br>            cd "$base_dir/$subject_name"<br>            subject_name1=$(basename "$subject_dir" .feat)<br>            output_file="${subject_name1}_${i}.csv"<br>            counter=0<br>            while read line; do<br>                IFS=',' read -r centerx centery centerz &lt;&lt;&lt; "$line" <br>                counter=$((counter+1))<br>                fslmaths roi_template.nii.gz -mul 0 -add 1 -roi $centerx 1 $centery 1 $centerz 1 0 1 ACCpoint -odt float<br>                fslmaths ACCpoint -kernel sphere 5 -fmean ACCsphere_$counter -odt float<br>                fslmaths ACCsphere_$counter.nii.gz -bin ACCsphere_bin_$counter.nii.gz<br>                roi_timeseries=$(fslmeants -i res_brain_std -m ACCsphere_bin_$counter)<br>                time_series="$roi_timeseries"<br>                echo "$time_series" &gt;&gt; $output_file<br>            done &lt; $file_path<br>            rm -r ACC*<br>        fi<br>    done<br>done</pre> <blockquote>How can you get timeseries for all ROIs at once ??🤔</blockquote> <p>All the csv files containing the timeseries at at CNStandard_name move them to another folder RAWtime</p> <pre>#!/bin/bash<br>base_dir="path/CNStandard_name"<br>for i in CB DMN FP OP CO SM; do<br>    out_path="path/RAWtime/CN/$i"<br>    mkdir -p "$out_path"<br>    for subject_dir in "$base_dir"/*.feat; do<br>        if [[ -d "$subject_dir" ]]; then<br>            subject_name=$(basename "$subject_dir")<br>            subject_name1=$(basename "$subject_dir" .feat)<br>            echo "$subject_name"<br>            cd "$base_dir/$subject_name" || exit 1  <br>            output_file="${subject_name1}_${i}.csv"<br>            cp "$output_file" "$out_path"<br>            subject_name1=$(basename "$subject_dir" .feat)<br>            new_file_name="$subject_name1.csv"<br>            mv "${out_path}/${output_file}" "${out_path}/${new_file_name}"<br>        fi<br>    done<br>done</pre> <p>Reshape the csv files from having one column to have rows as many as the ROIs and columns being the timestamps</p> <pre>import pandas as pd<br>import numpy as np<br>import os<br>networks = {<br>    'CB': 18,<br>    'CO':32,<br>    'DMN':34,<br>    'FP':21,<br>    'OP': 22,<br>    'SM':33<br>}<br>for net,roi in networks.items():<br>    path = f'path/RAWtime/CN/{net}'<br>    if os.path.exists(path):<br>        final_path= f'path/FMRtimeseries/CN/{net}'<br>        os.makedirs(final_path,exist_ok=True)<br>        for csv_path in os.listdir(path=path):<br>            print(csv_path)<br>            try:<br>                df = pd.read_csv(os.path.join(path,csv_path), header=None)<br>                data = np.reshape(df.to_numpy(), (roi, -1))<br>                new_df = pd.DataFrame(data)<br>                new_df.to_csv(f"{final_path}/sub_{csv_path[:-4]}.csv", header=False,index=False)<br>            except:<br>                print('Missing', csv_path)</pre> <p>If you have reached till here give a pat on your back !!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9157947b3e35" width="1" height="1" alt=""></p> </body></html>